function V_xyz = Gravitational_potential_cuboid(x, y, z, L, B, D, rho, G)
% gravitational potential V(x,y,z) due to a uniform solid cube or cuboid
% The general case is a cuboid with length 2L, breadth 2B and depth 2D in 
% the directions of the x, y and z axes respectively. One might think of
% L, B and D as Lx, Ly and Lz respectively. In the event that L=B=D then
% the cuboid reduces to a cube for which all edge lengths are 2L. The cube
% or cuboid is centered at the origin of the cartesian axis system. G is
% the Gravitational Constant (some normalizations set G = 1).
% The volume of the cuboid is 8*L*B*D, and the volume of the cube is 8*L^3.
% The density of the cube or cuboid is rho, and is assumed to be constant.
% 
% USAGE:  V_xyz = Gravitational_potential_cuboid(x, y, z, L, B, D, rho, G)
%
% where x, y and z can be scalars, vectors or matrices, but must have the 
% same size and shape. L, B and D must be positive scalars. Rho a non-zero 
% scalar but can be positive or negative. We follow Chappel et al. in using
% the commmon physics sign convention that V is negative, except at
% infinity where it is zero. The use shoud multiply the result by -1 in
% order to adopt the sign convention used by geodesists.
%
% Reference: Chappel et al. (2012) Physics International, v3, 50-57.

% This code is a slight modification of the Matlab code written by
% Thenendran Periyandy. Its vectorizaton was improved, and the comments 
% added by Michael Bevis on 14 December 2024.

    X1 = (L - x);  X2 = (L + x);
    X3 = (B - y);  X4 = (B + y);
    X5 = (D - z);  X6 = (D + z);
    
    V_xyz = term1(X1, X2, X3, X4, X5, X6) + ...
            term2(X1, X2, X3, X4, X5, X6) + ...
            term3(X1, X2, X3, X4, X5, X6) + ...
            term4(X1, X2, X3, X4, X5, X6) + ...
            term5(X1, X2, X3, X4, X5, X6) + ...
            term6(X1, X2, X3, X4, X5, X6);   
        
    V_xyz = -G * rho * V_xyz;
end

function T1 = term1(X1, X2, X3, X4, X5, X6)
T1 = X3 .* X5 .* sp_log(X1 + sqrt(X1.^2 + X3.^2 + X5.^2), ...
                      -X2 + sqrt(X2.^2 + X3.^2 + X5.^2)) + ...
     X3 .* X6 .* sp_log(X1 + sqrt(X1.^2 + X3.^2 + X6.^2), ...
                      -X2 + sqrt(X2.^2 + X3.^2 + X6.^2)) + ...
     X4 .* X5 .* sp_log(X1 + sqrt(X1.^2 + X4.^2 + X5.^2), ...
                      -X2 + sqrt(X2.^2 + X4.^2 + X5.^2)) + ...
     X4 .* X6 .* sp_log(X1 + sqrt(X1.^2 + X4.^2 + X6.^2), ...
                      -X2 + sqrt(X2.^2 + X4.^2 + X6.^2));
end

function T2 = term2(X1, X2, X3, X4, X5, X6)
T2 = -((X1.^2 / 2) .* ...
    (sp_arctan(X3 .* X5, X1 .* sqrt(X1.^2 + X3.^2 + X5.^2)) + ...
     sp_arctan(X3 .* X6, X1 .* sqrt(X1.^2 + X3.^2 + X6.^2)))) - ...
    ((X1.^2 / 2) .* ...
    (sp_arctan(X4 .* X5, X1 .* sqrt(X1.^2 + X4.^2 + X5.^2)) + ...
     sp_arctan(X4 .* X6, X1 .* sqrt(X1.^2 + X4.^2 + X6.^2)))) - ...
    ((X2.^2 / 2) .* ...
    (sp_arctan(X3 .* X5, X2 .* sqrt(X2.^2 + X3.^2 + X5.^2)) + ...
     sp_arctan(X3 .* X6, X2 .* sqrt(X2.^2 + X3.^2 + X6.^2)))) - ...
    ((X2.^2 / 2) .* ...
    (sp_arctan(X4 .* X5, X2 .* sqrt(X2.^2 + X4.^2 + X5.^2)) + ...
     sp_arctan(X4 .* X6, X2 .* sqrt(X2.^2 + X4.^2 + X6.^2))));
end

function T3 = term3(X1, X2, X3, X4, X5, X6)
T3 = X1 .* X5 .* sp_log(X3 + sqrt(X1.^2 + X3.^2 + X5.^2), ...
                     -X4 + sqrt(X1.^2 + X4.^2 + X5.^2)) + ...
     X1 .* X6 .* sp_log(X3 + sqrt(X1.^2 + X3.^2 + X6.^2), ...
                     -X4 + sqrt(X1.^2 + X4.^2 + X6.^2)) + ...
     X2 .* X5 .* sp_log(X3 + sqrt(X2.^2 + X3.^2 + X5.^2), ...
                     -X4 + sqrt(X2.^2 + X4.^2 + X5.^2)) + ...
     X2 .* X6 .* sp_log(X3 + sqrt(X2.^2 + X3.^2 + X6.^2), ...
                     -X4 + sqrt(X2.^2 + X4.^2 + X6.^2));
end

function T4 = term4(X1, X2, X3, X4, X5, X6)
T4 = -((X3.^2 / 2) .* ...
    (sp_arctan(X1 .* X5, X3 .* sqrt(X1.^2 + X3.^2 + X5.^2)) + ...
     sp_arctan(X1 .* X6, X3 .* sqrt(X1.^2 + X3.^2 + X6.^2)))) - ...
    ((X4.^2 / 2) .* ...
    (sp_arctan(X1 .* X5, X4 .* sqrt(X1.^2 + X4.^2 + X5.^2)) + ...
     sp_arctan(X1 .* X6, X4 .* sqrt(X1.^2 + X4.^2 + X6.^2)))) - ...
    ((X3.^2 / 2) .* ...
    (sp_arctan(X2 .* X5, X3 .* sqrt(X2.^2 + X3.^2 + X5.^2)) + ...
     sp_arctan(X2 .* X6, X3 .* sqrt(X2.^2 + X3.^2 + X6.^2)))) - ...
    ((X4.^2 / 2) .* ...
    (sp_arctan(X2 .* X5, X4 .* sqrt(X2.^2 + X4.^2 + X5.^2)) + ...
     sp_arctan(X2 .* X6, X4 .* sqrt(X2.^2 + X4.^2 + X6.^2))));
end

function T5 = term5(X1, X2, X3, X4, X5, X6)
T5 = X1 .* X3 .* sp_log(X5 + sqrt(X1.^2 + X3.^2 + X5.^2),...
                   -X6 + sqrt(X1.^2 + X3.^2 + X6.^2)) + ...
     X1 .* X4 .* sp_log(X5 + sqrt(X1.^2 + X4.^2 + X5.^2), ...
                   -X6 + sqrt(X1.^2 + X4.^2 + X6.^2)) + ...
     X2 .* X3 .* sp_log(X5 + sqrt(X2.^2 + X3.^2 + X5.^2),...
                   -X6 + sqrt(X2.^2 + X3.^2 + X6.^2)) + ...
     X2 .* X4 .* sp_log(X5 + sqrt(X2.^2 + X4.^2 + X5.^2), ...
                   -X6 + sqrt(X2.^2 + X4.^2 + X6.^2));
end

function T6 = term6(X1, X2, X3, X4, X5, X6)
T6 = -((X5.^2 / 2) .* ...
    (sp_arctan(X1 .* X3, X5 .* sqrt(X1.^2 + X3.^2 + X5.^2)) + ...
     sp_arctan(X1 .* X4, X5 .* sqrt(X1.^2 + X4.^2 + X5.^2)))) - ...
    ((X6.^2 / 2) .* ...
    (sp_arctan(X1 .* X3, X6 .* sqrt(X1.^2 + X3.^2 + X6.^2)) + ...
     sp_arctan(X1 .* X4, X6 .* sqrt(X1.^2 + X4.^2 + X6.^2)))) - ...
    ((X5.^2 / 2) .* ...
    (sp_arctan(X2 .* X3, X5 .* sqrt(X2.^2 + X3.^2 + X5.^2)) + ...
     sp_arctan(X2 .* X4, X5 .* sqrt(X2.^2 + X4.^2 + X5.^2)))) - ...
    ((X6.^2 / 2) .* ...
    (sp_arctan(X2 .* X3, X6 .* sqrt(X2.^2 + X3.^2 + X6.^2)) + ...
     sp_arctan(X2 .* X4, X6 .* sqrt(X2.^2 + X4.^2 + X6.^2))));
end

function result = sp_log(numerator, denominator)
%sp_log logarithm with special case hanling to avoid non-physical
% (purely numerical) singularities  when computing the gravity potential
result=zeros(size(numerator));
k= ( denominator~=0 );
result(k) = log(numerator(k)) - log(denominator(k));
end

function result = sp_arctan(numerator, denominator)
%sp_artcan arctangent with special case hanling to avoid physically
% incorrect outcomes when computing the gravity potential
result=zeros(size(numerator));
k= ( numerator~=0 & denominator~=0 );
result(k) = atan(numerator(k) ./ denominator(k));
end